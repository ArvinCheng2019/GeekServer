# Actor并发模型
actor模型是什么可以自行查阅一下相关资料；actor模型在一定程度可以说是解决并发的最佳方案。

GeekServer的actor可以简单理解为一个线程(其实用的是线程池)，一个actor的逻辑只需保证在自己的队列里面执行即保证可线程安全，无需关心锁的问题。GeekServer的基础就是actor，一切皆可为actor。GeekServer的actor模型构建于强大的TPL DataFlow之上，底层使用内置线程池。GeekServer同时使用异步变成（async/await），让逻辑代码更加清晰明了，符合人类的思维方式。

Actor模型本身是存在死锁的情况，且不容易被发现。GeekServer内部可检测环路死锁(即:A->B->C->A)，并采用调用链重入机制消除环路死锁（类似与线程的可重入性）。  
还有另外一种情况（多路死锁），比如有2个actor，A和B，一段逻辑A调用B，同时有另外一段逻辑发起了B调用A，就会出现A等B，B再等A，此时发生死锁。这种死锁无法避免，只能从设计上去规避（有几种比较折中设计方案，待续）  
```csharp
class ActorA
{
	Task A1()
	{
        await Task.Delay(10); 
		var b = GetActorB();
		return b.SendAsync(b.B1);
	}
	
	Task A2()
	{
		var b = GetActorB();
		return b.SendAsync(b.B1);
	}
}

class ActorB
{
	Task B1()
	{
		await Task.Delay(5);
		var a = GetActorA();
		return a.SendAsync(a.A2);
	}
}

Task Call()
{
	var a = GetActorA();
	return a.SendAsync(a.A1);//这里就会触发死锁
}
```

如果得到打印日志【执行超时】很有可能就是触发了死锁。由于Actor设定了超时时间，在断点调试的时候需要手动将超时时间改长，默认10秒，在BaseActor.TIME_OUT修改。（或者用一个Debug模式的宏来控制）